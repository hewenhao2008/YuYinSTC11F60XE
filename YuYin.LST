C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE YUYIN
OBJECT MODULE PLACED IN YuYin.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE YuYin.c OPTIMIZE(9,SPEED) BROWSE INCDIR(C:\Keil\C51\INC) DEBUG OBJECTEXTEND
                    - TABS(2)

line level    source

   1          #include "STC11F60XE.h"
   2          #include "intrins.h"
   3          #include "ds18b20.h"
   4          #include <string.h>
   5          
   6          sbit JS = P2 ^ 4;//红外接收端口!
   7          sbit Y  = P2 ^ 5; //红外发射端口   
   8          sbit WF = P0 ^ 4; //无线发射端口 
   9          
  10          sbit WIFI_LED = P3 ^ 6; //wifi复位LED指示灯
  11          sbit WAKEUP_LED = P0 ^ 3; //唤醒状态指示灯
  12          sbit RST = P1 ^ 4; //wifi复位RST 
  13          
  14          #define LED_ON 1
  15          #define LED_OFF !(LED_ON)
  16          
  17          bit F = 0;    //是否打开38KH方波调制
  18          bit Wifi_Command_Mode = 0; //=1 wifi工作在命令模式 =0 工作在数据传输模式
  19          bit Check_wifi = 1;
  20          unsigned int Wifi_AP_OPEN_MODE = 0;
  21          unsigned int RST_count1 = 0; //计数
  22          unsigned int RST_count2 = 0;
  23          unsigned char Temperature = 0; //温度
  24          unsigned int T = 0; //计数
  25          
  26          
  27          unsigned int i = 0;//计数用 
  28          unsigned int j = 0;//计数用
  29          unsigned int c = 0;//计数用
  30          
  31          unsigned int ui = 0;//串口接收数据长度!
  32          xdata unsigned char US[800];//xdata unsigned char US[256]; //定义串口接收数据变量!
  33          
  34          /*
  35          void Delay10us()    //@22.1184MHz
  36          {
  37            unsigned char i;
  38          
  39            _nop_();
  40            i = 52;
  41            while (--i);
  42          }
  43          */
  44          
  45          void U1_in()//串口1接收数据
  46          {
  47   1        j = 0; //超时退出!
  48   1        ui = 0;
  49   1        while(j < 40000)//超时退出(大约1ms)!需要测试此值是否正确! 5000
  50   1        {
  51   2          if(RI == 1)
  52   2          {
  53   3            US[ui] = SBUF;
  54   3            if(US[ui] == '<' && US[ui - 1] == '<')
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 2   

  55   3              break;
  56   3            RI = 0;
  57   3            ui++;
  58   3            j = 0;      
  59   3          }
  60   2          else
  61   2            j++;
  62   2          //Delay10us();//延时时间需要测试此值是否正确!(此处要加延时,要不数据接收不正确!)
  63   2        } 
  64   1        RI = 0; 
  65   1      }
  66          
  67          void U1_send(unsigned char i)//串口1发送单字节数据
  68          {
  69   1        TI = 0;     //令接收中断标志位为0（软件清零）
  70   1        SBUF = i; //接收数据 SBUF 为单片机的接收发送缓冲寄存器
  71   1        while(TI==0);
  72   1        TI = 0;     //令接收中断标志位为0（软件清零）
  73   1      }
  74          
  75          void U1_sendS(unsigned char s[], unsigned int m)//串口1发送字符串数据,U1_sendS函数必须加"<<"结束标志!
  76          {
  77   1        unsigned int n = 0;
  78   1        for(n = 0;n < m;n++)
  79   1          U1_send(s[n]);
  80   1      }
  81          
  82          
  83          void T0Init(void)   //13微秒@22.1184MHz
  84          {
  85   1        AUXR &= 0x7F;   //定时器时钟12T模式
  86   1        TMOD &= 0xF0;   //设置定时器模式
  87   1        TMOD |= 0x02;   //设置定时器模式
  88   1        TL0 = 0xE8;   //设置定时初值
  89   1        TH0 = 0xE8;   //设置定时重载值
  90   1        TF0 = 0;    //清除TF0标志
  91   1        TR0 = 0;    //定时器0开始计时
  92   1        
  93   1        ET0 = 1;
  94   1        EA = 1;
  95   1      }
  96          
  97          void T0_C1 (void) interrupt 1  using 2 //单片机的中断号1对应的中断:定时器中断0
  98          {    
  99   1        T++;
 100   1        if(F == 1)
 101   1            Y = ~Y;
 102   1      }
 103          
 104          typedef union //char型数据转int型数据类 
 105          {  
 106            unsigned short int ue; 
 107            unsigned char    u[2]; 
 108          }U16U8;
 109          U16U8 idata M;//两个8位转16位
 110          
 111          void U1Init(void)   //115200bps@22.1184MHz
 112          {
 113   1        PCON |= 0x80;   //使能波特率倍速位SMOD
 114   1        SCON = 0x50;    //8位数据,可变波特率
 115   1        AUXR |= 0x04;   //独立波特率发生器时钟为Fosc,即1T
 116   1        BRT = 0xF4;   //设定独立波特率发生器重装值
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 3   

 117   1        AUXR |= 0x01;   //串口1选择独立波特率发生器为波特率发生器
 118   1        AUXR |= 0x10;   //启动独立波特率发生器
 119   1      }
 120          
 121          void Rstinit()
 122          {
 123   1        //配置为仅输入
 124   1        P1M1 |= (1<<4);
 125   1        P1M0 &= ~(1<<4);
 126   1      }
 127          
 128          /*--------------
 129          ---wifi mode----
 130          --------------*/
 131          void Delay10ms()    //@22.1184MHz
 132          {
 133   1        unsigned char i, j, k;
 134   1      
 135   1        i = 1;
 136   1        j = 216;
 137   1        k = 35;
 138   1        do
 139   1        {
 140   2          do
 141   2          {
 142   3            while (--k);
 143   3          } while (--j);
 144   2        } while (--i);
 145   1      }
 146          
 147          /*
 148          void Delay100ms()   //@22.1184MHz
 149          {
 150            unsigned char i, j, k;
 151          
 152            i = 9;
 153            j = 104;
 154            k = 139;
 155            do
 156            {
 157              do
 158              {
 159                while (--k);
 160              } while (--j);
 161            } while (--i);
 162          }
 163          */
 164          
 165          void Timer1Init(void)   //5毫秒@22.1184MHz
 166          {
 167   1        AUXR &= 0xBF;   //定时器时钟12T模式
 168   1        TMOD &= 0x0F;   //设置定时器模式
 169   1        TMOD |= 0x10;   //设置定时器模式
 170   1        TL1 = 0x00;   //设置定时初值
 171   1        TH1 = 0xDC;   //设置定时初值
 172   1        TF1 = 0;    //清除TF1标志
 173   1        TR1 = 1;    //定时器1开始计时
 174   1        
 175   1        ET1 =1;
 176   1        EA = 1;
 177   1      }
 178          
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 4   

 179          
 180          void T1() interrupt 3 using 3
 181          {
 182   1        if(Wifi_AP_OPEN_MODE)
 183   1        {
 184   2          //U1_send('2');
 185   2          Wifi_AP_OPEN_MODE++;
 186   2          if(Wifi_AP_OPEN_MODE == 50)
 187   2          {
 188   3            //U1_send('3');
 189   3            WIFI_LED = !WIFI_LED;
 190   3            Wifi_AP_OPEN_MODE = 1;
 191   3          }
 192   2        }
 193   1        TL1 = 0x00;   //设置定时初值
 194   1        TH1 = 0xDC;   //设置定时初值  
 195   1        TR1 = 1;    //定时器1开始计时 
 196   1      }
 197          
 198          /*
 199          void wifi_ap_open_led_blink()
 200          {
 201            //灯闪烁处理
 202            WIFI_LED = !WIFI_LED;
 203            //Delay100ms();
 204            Delay50ms();
 205            WIFI_LED = !WIFI_LED; 
 206            Delay50ms();
 207            //Delay100ms(); 
 208          }
 209          */
 210          int start_wifi_command()
 211          {
 212   1        U1_sendS("+++",3);
 213   1        memset(US,0x00,sizeof(US)); 
 214   1        U1_in();
 215   1        if(US[0] == 'a')
 216   1        { 
 217   2          memset(US,0x00,sizeof(US));
 218   2          //Delay50ms();
 219   2          U1_send('a');
 220   2          U1_in();      
 221   2          if(strstr(US,"+ok") != NULL)
 222   2          {
 223   3            Wifi_Command_Mode = 1;
 224   3            memset(US,0x00,sizeof(US));
 225   3            return 0; //切换成功
 226   3          } 
 227   2        }
 228   1        memset(US,0x00,sizeof(US));
 229   1        return 1;
 230   1      }
 231          
 232          int start_wifi_data()
 233          {
 234   1        U1_sendS("AT+ENTM\r\n",9);
 235   1        U1_in();
 236   1        if(strstr(US,"+ok") != NULL)
 237   1        {   
 238   2          Wifi_Command_Mode = 0;
 239   2          memset(US,0x00,sizeof(US));
 240   2          return 0; //切换成功
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 5   

 241   2        }
 242   1        memset(US,0x00,sizeof(US));
 243   1        return 1; 
 244   1      }
 245          
 246          void main (void)
 247          {
 248   1        WF = 0;
 249   1        WIFI_LED =LED_ON;// LED_ON;
 250   1        WAKEUP_LED = LED_OFF;
 251   1        U1Init();
 252   1        T0Init(); 
 253   1        Timer1Init();
 254   1        Rstinit();
 255   1        Init_DS18B20(); 
 256   1        //CH:<<       红外采集命令    //CH:长度+数据<<  //采集后返回的数据
 257   1        //FH:长度+数据<<  红外发射命令
 258   1        //FW:长度+数据<<    无线发射命令
 259   1        //FS:<<       心跳
 260   1        //网络传来的是byte格式的数据
 261   1        //while(1);
 262   1        while(1)
 263   1        {
 264   2          if(Check_wifi)
 265   2          {
 266   3            if(!Wifi_Command_Mode)
 267   3            {
 268   4              start_wifi_command();
 269   4            }
 270   3            if(Wifi_Command_Mode)
 271   3            {
 272   4              Delay10ms();
 273   4              U1_sendS("AT+WMODE\r\n",10);
 274   4              Check_wifi = 0; 
 275   4            }
 276   3          } 
 277   2          if(!Wifi_AP_OPEN_MODE)
 278   2            WIFI_LED = RST; 
 279   2          if(RST == 0)
 280   2          {
 281   3            TR1 = 0;
 282   3            WIFI_LED = RST;
 283   3            while(RST == 0)
 284   3            {
 285   4              RST_count1++;
 286   4              if(RST_count1 == 65535)
 287   4              {
 288   5                RST_count1 = 0;
 289   5                RST_count2++;
 290   5              }
 291   4            }
 292   3            if(RST_count2 >= 5)
 293   3            {
 294   4              Wifi_Command_Mode = 0;
 295   4              Check_wifi = 1;
 296   4              RST_count1 = 0;
 297   4              RST_count2 = 0;
 298   4            } 
 299   3            TR1 = 1;
 300   3          } 
 301   2          if(RI==1)
 302   2          {
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 6   

 303   3            U1_in();//获取串口发送的SJ数据!
 304   3      
 305   3            if(US[2] == ':')//接收到正确的控制数据!
 306   3            {
 307   4              switch(US[0])
 308   4              {
 309   5                case 'F'://红外、无线数据发射!
 310   5                  WIFI_LED = LED_OFF;
 311   5                  if(US[1]=='H')//红外
 312   5                  {             
 313   6                    i = 4;//第3与4位是数据长度,从第4位是红外、无线控制数据
 314   6                    M.u[0] = US[3];
 315   6                    M.u[1] = US[4];
 316   6                    j = M.ue;           
 317   6                    TR0 = 1;    //启动定时器0
 318   6                    while(i < j)//j是数据长度-1!
 319   6                    {
 320   7                      T = 0;
 321   7                      F = 1;
 322   7                      i++;
 323   7                      if(US[i] == 0)//&&US[i+1]==0)
 324   7                      {
 325   8                        i += 2;
 326   8                        M.u[0] = US[i];
 327   8                        i++;  
 328   8                        M.u[1] = US[i];
 329   8                      }
 330   7                      else
 331   7                      {
 332   8                        M.u[0] = 0; 
 333   8                        M.u[1] = US[i];
 334   8                      }
 335   7                      while(T < M.ue);
 336   7      
 337   7                      T = 0;
 338   7                      F = 0;
 339   7                      Y = 1;
 340   7                      i++;
 341   7                      if(US[i] == 0)//&&uip_appdata[i+1]==0)
 342   7                      {
 343   8                        i += 2;
 344   8                        M.u[0] = US[i];
 345   8                        i++;  
 346   8                        M.u[1] = US[i];
 347   8                      }
 348   7                      else
 349   7                      {
 350   8                        M.u[0] = 0; 
 351   8                        M.u[1] = US[i];
 352   8                      }
 353   7                      while(T < M.ue);                
 354   7                    }
 355   6                    TR0 = 0;    //关闭定时器0
 356   6                    U1_sendS("FH<<", 4); 
 357   6                    WIFI_LED = LED_ON;
 358   6                  }
 359   5                  else if(US[1]=='W')
 360   5                  {           
 361   6                    c = 0;
 362   6                    TR0 = 1;    //启动定时器0
 363   6                    while(c < 6)//重复次数!
 364   6                    {
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 7   

 365   7                      T = 0;
 366   7                      WF = 1;
 367   7                      i = 4;//第3与4位是数据长度,从第5位是红外、无线控制数据
 368   7                      while(T < 28);//(13 * 808 = 10504同步脉宽!                  
 369   7                      T = 0;
 370   7                      WF = 0;
 371   7                      M.u[0] = US[3];
 372   7                      M.u[1] = US[4];
 373   7                      j = M.ue;//主机生成的长度要减1
 374   7                      while(T < 808);//(13 * 808 = 10504同步脉宽!
 375   7      
 376   7                      while(i < j)
 377   7                      {
 378   8                        T = 0;
 379   8                        WF = 1;
 380   8                        i++;
 381   8                        while(T < US[i]);
 382   8      
 383   8                        T = 0;
 384   8                        WF = 0;
 385   8                        i++;//i在此,精准一些
 386   8                        while(T < US[i]);
 387   8                      }
 388   7                      c++;
 389   7                    }
 390   6                    TR0 = 0;
 391   6                    WF = 0;   //关闭定时器0
 392   6                    U1_sendS("FW<<", 4);
 393   6                  }
 394   5                  else if(US[1]=='S')
 395   5                  {
 396   6                    U1_sendS("FS<<", 4);
 397   6                  }
 398   5      
 399   5                  break;
 400   5      
 401   5                case 'C'://红外采集!
 402   5                  U1_sendS("CA<<", 4);//返回到主机请按遥控器("<<"在U1_sendS中添加)
 403   5                  i = 5;//第3与4位是数据长度,从第4位是红外、无线控制数据
 404   5                  j = 0;
 405   5                  TR0 = 1;    //启动定时器0
 406   5                  while(i < 756) //长度给这句有关-->>US[2] = i;//第三位是数据长度
 407   5                  { 
 408   6                    T = 1;   //应该能提高准确率
 409   6                    while(JS == 0);
 410   6                    if(T > 5)
 411   6                    {
 412   7                      M.ue = T;
 413   7                      T = 1;
 414   7                      if(M.u[0] > 0)
 415   7                      {
 416   8                        US[i] = 0;  //将接收的数据发送回去（删除//即生效）
 417   8                        i++;
 418   8                        US[i] = 0;  //将接收的数据发送回去（删除//即生效）
 419   8                        i++;
 420   8                        US[i] = M.u[0]; //将接收的数据发送回去（删除//即生效）
 421   8                        i++;
 422   8                      }
 423   7                      US[i] = M.u[1];
 424   7                      i++;  
 425   7                      while(JS == 1)
 426   7                      {               
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 8   

 427   8                        if(T > 6000)//无数据退出                
 428   8                        {
 429   9                          US[i] = 0;
 430   9                          i++;
 431   9      
 432   9                          M.ue = i;
 433   9                          US[3] = M.u[0];//第3与4位是数据长度(包括数据头,不包括结尾!)
 434   9                          US[4] = M.u[1];//第3与4位是数据长度(包括数据头,不包括结尾!)
 435   9                               
 436   9                          US[i] = '<';
 437   9                          i++;
 438   9                          US[i] = '<';
 439   9                          i++;
 440   9      
 441   9                          US[0] = 'C';
 442   9                          US[1] = 'H';
 443   9                          US[2] = ':';                                  
 444   9                          U1_sendS(US, i);//红外采集成功
 445   9      
 446   9                          i = 756;
 447   9                          break;
 448   9                        }
 449   8                      }
 450   7                      if(i < 756)
 451   7                      {       
 452   8                        M.ue = T;
 453   8              
 454   8                        if(M.u[0] > 0)
 455   8                        {
 456   9                          US[i] = 0;
 457   9                          i++;
 458   9                          US[i] = 0;
 459   9                          i++;
 460   9                          US[i] = M.u[0];
 461   9                          i++;
 462   9                        }
 463   8                        US[i] = M.u[1];
 464   8                        i++;
 465   8                        j = 0;
 466   8                      }
 467   7                    }
 468   6                    else
 469   6                    {
 470   7                      while(JS == 1)
 471   7                      {
 472   8                        if(T > 50000)
 473   8                        {
 474   9                          T = 0;
 475   9                          j++;
 476   9                          if(j > 30)
 477   9                          {
 478  10                            i = 756;
 479  10                            U1_sendS("CC<<", 4);//超时退出!大约20秒无操作退出!
 480  10                            break;
 481  10                          }
 482   9                        }
 483   8                      }
 484   7                    }
 485   6                  }
 486   5                  TR0 = 0;    //关闭定时器0
 487   5                  break;
 488   5                case 'D':   //温度
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 9   

 489   5                    if(US[1] == 'T')
 490   5                    {
 491   6                      memset(US,0x00,sizeof(US));
 492   6                      US[0] = 'D';
 493   6                      US[1] = 'T';
 494   6                      while((US[2] = GetTemperature()) == 0x55);
 495   6                      US[3] = '<';
 496   6                      US[4] = '<';
 497   6                      U1_sendS(US, 5);
 498   6                    }
 499   5                    else if(US[1] == 'S') //wifi复位
 500   5                    {
 501   6                      Check_wifi = 1;
 502   6                      Wifi_Command_Mode = 0;
 503   6                      U1_sendS("DS<<",4);
 504   6                    }
 505   5                    break;
 506   5                case 'L': //唤醒状态指示灯
 507   5                    if(US[1] == 'B')
 508   5                    {
 509   6                      WAKEUP_LED = LED_ON;
 510   6                      U1_sendS("LB<<",4);
 511   6                    } 
 512   5                    else if(US[1] == 'D')
 513   5                    {
 514   6                      WAKEUP_LED = LED_OFF;
 515   6                      U1_sendS("LD<<",4);
 516   6                    }
 517   5                    break;
 518   5                default:break;  
 519   5              }
 520   4            }
 521   3            else if(strstr(US,"+o") != NULL) //收到wifi模块返回的数据 +ok
 522   3            {
 523   4              if(strstr(US,"AP") != NULL)   //wifi工作在AP模式
 524   4              {
 525   5                Delay10ms();
 526   5                U1_sendS("AT+WAKEY\r\n",10);
 527   5              }
 528   4              else if(strstr(US,"OPEN") != NULL) //AP模式下的open加密  
 529   4              {
 530   5                Check_wifi = 0;
 531   5                Wifi_AP_OPEN_MODE = 1;
 532   5                TR1 = 1;
 533   5                if(start_wifi_data())
 534   5                {
 535   6                  Check_wifi = 0;
 536   6                  Wifi_Command_Mode = 0;
 537   6                }
 538   5              }
 539   4              else
 540   4              {
 541   5                start_wifi_data();
 542   5                Check_wifi = 0;
 543   5                TR1 = 0;
 544   5                Wifi_Command_Mode = 0;
 545   5                Wifi_AP_OPEN_MODE = 0;
 546   5              }
 547   4            }
 548   3          }
 549   2          US[2] = 0x00;//一个串口命令执行完毕, 清空
 550   2        }
C51 COMPILER V9.01   YUYIN                                                                 09/09/2013 19:00:55 PAGE 10  

 551   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1695    ----
   CONSTANT SIZE    =     91    ----
   XDATA SIZE       =    800    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17       5
   IDATA SIZE       =      2    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
